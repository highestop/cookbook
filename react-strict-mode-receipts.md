# React Strict Mode Receipts

Recommend to read:

- [Escape Hatches](https://react.dev/learn/escape-hatches)
- [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)
- [Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)
- [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
- [Keeping Components Pure](https://react.dev/learn/keeping-components-pure)
- [StrictMode](https://react.dev/reference/react/StrictMode)

React Philosophy:

*StrictMode `doubleInvoke` renders component twice continuously, all before `useEffect` setup and cleanup runs. The memorizedState of this component for `useEffect` hook only holds the state (create and destroy callback) the second rendering returns (setup and cleanup function).*

*In StrictMode, two closures are created by two rendering, but the first closure is abandoned. You have no chance to cleanup the side effects you created in rendering if you do so. Also, the `useEffect` setup will run twice, but cleanup only once. if you do more or less thing inside two callbacks, which leads to asymmetric, React will expose them.*

*Because of StrictMode `doubleInvoke`, instead of normal re-render, hooks like `useRef` or `useState` are NOT actually an init-once-only thing, they will run twice. In fact, anything that gains a value during rendering should be considered as a side effect. You neither do it this way nor do not depend on its value when you intend to change it in Effect, which means if you change `ref.current` in `useEffect` cleanup, you should re-gain its value in `useEffect` setup, even if you think you've inited it in `useRef`.*

*React never guarantee how many times component rendering or `useEffect` would run. So StrictMode abandons the first rendering and doubles the effect (of the second rendering), and it should result in the same.*

![image](https://github.com/user-attachments/assets/e0490598-0739-4c5d-9a93-82da26cbf0b3)

## DO reset useRef value in useEffect setup, if it might be changed in cleanup.

```tsx
let id = 0;

function App() {
    const flag = useRef(id++);
    const foo = useRef(false);
    console.log('render', flag.current, foo.current);
    useEffect(() => {
        // foo.current = false; // ✅ you should add this line to fix it
        console.log('setup', flag.current, foo.current);
        return () => {
            foo.current = true;
            ids.delete(flag.current);
            console.log('cleanup', flag.current, foo.current);
        };
    });
    return null;
}
```

👉🏻 not in StrictMode

```
render  0 false
setup   0 false
```

👉🏻 in StrictMode

```
render  0 false
render  1 false
setup   1 false
cleanup 1 true
setup   1 true    ❌ expects false
```

In this case, the first time `useEffect` cleanup is called, it changes the ref value to `true`. You do nothing about this ref anymore in `useEffect` setup, so the value remains `true` at last.

To fix this, you should set this ref value to `false` in `useEffect` setup, resetting it with initial value when the `useEffect` setup is called the second chance.

## DO NOT cause side effect during rendering, like making connection between React and the outside world.

```tsx
let id = 0;
let cbs = new Set<(id: number) => void>();

function useApp() {
    const flag = useRef(id++);
    const [state, setState] = useState();
    cbs.add(setState); // ✅ should cut this line (global effects should NOT be created during rendering)
    useEffect(() => {
        // cbs.add(setState); // ✅ and paste here (should be created in effect setup instead)
        return () => {
            cbs.delete(setState);
        };
    });
    return state;
}
function App() {
    const state = useApp();
    return <span>{state}</span>;
}
setTimeout(() => {
    Array.from(cbs).map((cb) => cb(id));
}, 2000);
```

👉🏻 not in StrictMode

```
render 1
```

👉🏻 in StrictMode

```
render undefined // ❌ expects 2 (doubleInvoke causes id increasing twice, so should be 2 not 1)
```

In this case, when the first time `useEffect` cleanup is called, it clears the `setState` generated by second rendering. In the end, the first `setState` remains in the callbacks list, but the Component is rendered by the second `state`. After timeout macrotask, calling the first `setState` wouldn't update the second `state`, so we see nothing rendered.

To fix this, you shouldn't inject `setState` outside React during rendering, because it's a kind of side effect for rendering. Rendering should be pure. Instead, do it in `useEffect` setup, and eject it in the cleanup callback generated by this setup.

## DO NOT cause side effects in useMemo/useCallback

```tsx
let obj = {
    list: [1, 2, 3],
};
function App() {
    const state = useMemo(() => {
        obj.list.reverse();
        return obj;
    });
    console.log(state);
    return null;
}
```

👉🏻 in StrictMode

```
[3,2,1]
[1,2,3]
```

The calculation inside `useMemo` should be pure function. Like `reverse`, `splice` operation on an Array causes side effects. In this perspective, all dependencies for `useMemo` / `useCallback` should be immutable, you should return a new object.
